# æ“ä½œç³»ç»Ÿè¯¾ç¨‹

## æ–¯å¦ç¦CS140

[å®˜ç½‘CS140-winter2020](https://www.scs.stanford.edu/20wi-cs140/)

å‚è€ƒä¹¦ï¼š[Operating System Concepts](https://codex.cs.yale.edu/avi/os-book/OS10/index.html)

### 1. Introduction

è¯¾ç¨‹è®¨è®ºçš„ä¸»é¢˜ï¼š

* çº¿ç¨‹å’Œè¿›ç¨‹
* å¹¶å‘å’ŒåŒæ­¥
* è°ƒåº¦ï¼ˆSchedulingï¼‰
* è™šæ‹Ÿå†…å­˜ï¼ˆVirtual memoryï¼‰
* IO
* ç£ç›˜/æ–‡ä»¶ç³»ç»Ÿ
* ä¿æŠ¤ä¸å®‰å…¨
* è™šæ‹Ÿæœº
* ä»¥Unixä½œä¸ºä¸€ä¸ªä¾‹å­

#### è¯¾ç¨‹ç›®æ ‡

* ä»‹ç»æ“ä½œç³»ç»Ÿçš„æ¦‚å¿µ

  * ä¸å’Œæ“ä½œç³»ç»Ÿäº¤äº’ï¼Œç”µè„‘ä¼šéš¾ä»¥ä½¿ç”¨
  * ç†è§£æ“ä½œç³»ç»Ÿè®©ç¼–ç¨‹æ›´åŠ é«˜æ•ˆ

* æ€»ä½“æ¶µç›–å…³é”®çš„ç³»ç»Ÿæ¦‚å¿µ

  * ç¼“å­˜ï¼Œå¹¶å‘ï¼Œå­˜å‚¨ç®¡ç†ï¼ŒIOï¼Œä¿æŠ¤

* å­¦ä¹ å¤„ç†æ›´å¤§çš„è½¯ä»¶ç³»ç»Ÿ

* ä¸ºè¿›ä¸€æ­¥å­¦ä¹ æ‰“åŸºç¡€ï¼ˆCS-240ï¼‰

  ç¼–ç¨‹ä»»åŠ¡ï¼š

* å®ç°éƒ¨åˆ†Pintoæ“ä½œç³»ç»Ÿ

* ä¸€ä¸ªæ­å»ºä»»åŠ¡

* å››ä¸ªå®ç°å·¥ç¨‹

  * çº¿ç¨‹
  * ç”¨æˆ·è¿›ç¨‹
  * è™šæ‹Ÿå­˜å‚¨
  * æ–‡ä»¶ç³»ç»Ÿ



#### ä»€ä¹ˆæ˜¯æ“ä½œç³»ç»Ÿ

åœ¨åº”ç”¨ç¨‹åºå’Œç¡¬ä»¶ä¹‹é—´çš„å±‚

![image-20200326130458693](C:%5CUsers%5CAdministrator%5CDesktop%5Cnote%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B.assets%5Cimage-20200326130458693.png)

* è®©ç¨‹åºå‘˜å¾ˆå¥½çš„ä½¿ç”¨ç¡¬ä»¶
* ï¼ˆUsuallyï¼‰ä¸ºåº”ç”¨ç¨‹åºæä¾›æŠ½è±¡
  * ç®¡ç†å’Œéšè—ç¡¬ä»¶çš„ç»†èŠ‚
  * åº”ç”¨ç¨‹åºä¸åŒé€šè¿‡åº•å±‚çš„æ¥å£è·å¾—ç¡¬ä»¶çš„è®¿é—®æƒ
* ï¼ˆOftenï¼‰æä¾›ä¿æŠ¤
  * é˜²æ­¢ä¸€ä¸ªè¿›ç¨‹æˆ–è€…ç”¨æˆ·å½±å“åˆ°å…¶ä»–ç”¨æˆ·æˆ–è€…è¿›ç¨‹

#### ä¸ºä½•å­¦ä¹ æ“ä½œç³»ç»Ÿ

* æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªæˆç†Ÿçš„é¢†åŸŸ
  * å¤§å¤šæ•°äººåªä½¿ç”¨æˆç†Ÿæ“ä½œç³»ç»Ÿçš„ä¸€éƒ¨åˆ†
  * å¾ˆéš¾è®©äººåˆ‡æ¢æ“ä½œç³»ç»Ÿ
  * Hard to have impact with a new OS
* æ“ä½œç³»ç»Ÿä¾ç„¶æœ‰ä¸€äº›å¼€æ”¾çš„é—®é¢˜
  * å®‰å…¨-Hard to achieve security without a solid foundation
  * å¯æ‰©å±•-â€“ How to adapt concepts when hardware scales 10Ã— (fast networks, low service times, high core counts, big data... )
* é«˜æ€§èƒ½æœåŠ¡å™¨æ˜¯ä¸€ä¸ªæ“ä½œç³»ç»Ÿçš„è®®é¢˜
* èµ„æºæ¶ˆè€—æ˜¯æ“ä½œç³»ç»Ÿçš„è®®é¢˜
  * ç”µæ± å¯¿å‘½ï¼Œæ— çº¿ç”µç­‰ç­‰
* æ–°çš„æ™ºèƒ½è®¾å¤‡éœ€è¦æ–°çš„æ“ä½œç³»ç»Ÿ

#### åŸå§‹çš„æ“ä½œç³»ç»Ÿ

åªæœ‰ä¸€äº›æ ‡å‡†çš„æœåŠ¡ï¼ˆæ²¡æœ‰ä¿æŠ¤ï¼‰

* Simplifying assumptions
  * \- System runs one program at a time
  * No bad users or programs (oen bad assumption)
* é—®é¢˜ï¼šä½æ•ˆçš„åˆ©ç”¨
  * å¯¹äºç¡¬ä»¶ï¼ˆåœ¨ç­‰å¾…ç£ç›˜æ—¶CPUç©ºé—²ï¼‰
  * å¯¹äºç”¨æˆ·æ“ä½œï¼ˆå¿…é¡»ç­‰å¾…æ¯ä¸ªè¿›ç¨‹å®Œæˆï¼‰

#### å¤šä»»åŠ¡

æ€æƒ³ï¼šå¯ä»¥æœ‰å¤šä¸ªè¿›ç¨‹åŒæ—¶è¿è¡Œ

When one process blocks (waiting for disk, network, user input, etc.) run another process

#### å¤šç”¨æˆ·æ“ä½œç³»ç»Ÿ

* è®¸å¤šæ“ä½œç³»ç»Ÿä½¿ç”¨ä¿æŠ¤æœåŠ¡äºä¸åŒçš„ç”¨æˆ·æˆ–è€…åº”ç”¨
* æ€æƒ³ï¼šæœ‰Nä¸ªä½¿ç”¨è€…ï¼Œç³»ç»Ÿä¸ä¼šæˆNå€çš„é€Ÿåº¦ä¸‹é™
  * ç”¨æˆ·è¯·æ±‚CPUï¼Œå­˜å‚¨æ˜¯é—´æ­‡æ€§çš„
  * è°çœŸçš„éœ€è¦èµ„æºå°±è¢«åˆ†é…
* What can go wrong?
  * ç”¨æˆ·æ˜¯è´ªå©ªçš„ï¼Œä½¿ç”¨å¤ªå¤šçš„CPU
  * éœ€è¦çš„å­˜å‚¨å¤§äºæœºå™¨çš„å†…å­˜
  * éšç€éœ€æ±‚çš„å¢åŠ ï¼Œæ“ä½œç³»ç»Ÿä¼šè¶…çº¿æ€§çš„é€Ÿåº¦é™ä½

#### ä¿æŠ¤

* Mechanisms that isolate bad programs and people
* ä¼˜å…ˆåˆ†é…
  * Give application a resource, take it away if needed elsewhere
* å¹²æ¶‰/è°ƒåœ
  * Place OS between application and â€œstuffâ€
  * Track all pieces that application allowed to use
  * On every access, look in table to check that access legal
* CPUä¸­çš„ç‰¹æƒå’Œéç‰¹æƒæ¨¡å¼
  * Applications unprivileged (unprivileged user mode)
  * OS privileged (privileged supervisor/kernel mode)
  * Protection operations can only be done in privileged mode

#### ç»å…¸çš„æ“ä½œç³»ç»Ÿç»“æ„

![image-20200327102336298](C:%5CUsers%5CAdministrator%5CDesktop%5Cnote%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B.assets%5Cimage-20200327102336298.png)

* å¤§å¤šæ•°è½¯ä»¶éƒ½æ˜¯è¿è¡Œåœ¨ç”¨æˆ·å±‚çš„è¿›ç¨‹ä¸­

  è¿›ç¨‹çº¦ç­‰äºç¨‹åºå®ä¾‹

* æ“ä½œç³»ç»Ÿå†…æ ¸è¿è¡Œåœ¨ç‰¹æƒæ¨¡å¼ä¸­ï¼ˆæ©™è‰²éƒ¨åˆ†ï¼‰

  * åˆ›å»º/åˆ é™¤è¿›ç¨‹
  * å¯è®¿é—®ç¡¬ä»¶

#### ç³»ç»Ÿè°ƒç”¨

![image-20200327102610352](C:%5CUsers%5CAdministrator%5CDesktop%5Cnote%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B.assets%5Cimage-20200327102610352.png)

* åº”ç”¨å¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨å†…æ ¸
  * Special instruction transfers control to kernel
  * which dispatches to one of few hundred syscall handlers
* ç›®æ ‡ï¼šå¯ä»¥åœ¨éç‰¹æƒæ¨¡å¼ä¸‹å®Œæˆçš„äº‹æƒ…
  * åƒåº“è°ƒç”¨ï¼Œä½†æ˜¯into more privileged kernel code
* å†…æ ¸æä¾›äº†ä¼˜ç§€å®šä¹‰çš„ç³»ç»Ÿè°ƒç”¨æ¥å£
  * \- Applications set up syscall arguments and trap to kernel
  * Kernel performs operation and returns result
* é«˜å±‚çš„å‡½æ•°æ˜¯åŸºäºsyscallæ¥å£
  * printf, scanf, fgets, etc. éƒ½æ˜¯ç”¨æˆ·å±‚çš„ä»£ç 
* ä¾‹å­ï¼šPOSIX/UNIXæ¥å£
  * open, close, read, write, ...

#### ç³»ç»Ÿè°ƒç”¨çš„ä¾‹å­

![image-20200327103141314](C:%5CUsers%5CAdministrator%5CDesktop%5Cnote%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B.assets%5Cimage-20200327103141314.png)

* æ ‡å‡†åº“æ˜¯æ ¹æ®syscallså®ç°çš„
  * printf in libc, has same privileges as application
  * calls writeâ€“ in kernel, which can send bits out serial port

##### UNIXæ–‡ä»¶çš„syscall

åº”ç”¨é€šè¿‡æ–‡ä»¶åæ‰“å¼€æ–‡ä»¶

1. I/O happens through open filesï¼ˆæ‰“å¼€æ–‡ä»¶ä¼šæœ‰IOæ“ä½œï¼‰

```c
int open(char *path, int flags, /*int mode*/...);
```

* flags: O_RDONLY, O_WRONLY, O_RDWR

* O_CREAT: create the file if non-existent
* O_EXCL: (w. O_CREAT) create if file exists already
* O_EXCL: (w. O_CREAT) create if file exists already
* O_EXCL: (w. O_CREAT) create if file exists already
* mode: final argument with O_CREAT

2. è¿”å›æ–‡ä»¶æè¿°ç¬¦ç”¨äºæ‰€æœ‰çš„IOåˆ°æ–‡ä»¶

##### é”™è¯¯è¿”å›

* å¦‚æœ`open`æ“ä½œå¤±è´¥ï¼Œè¿”å›-1
* å¤§å¤šæ•°ç³»ç»Ÿåœ¨å¤±è´¥çš„æ—¶å€™è¿”å›-1
* \#include  for possible values
  * 2 = ENOENT â€œNo such file or directoryâ€
  * 13 = EACCES â€œPermission Deniedâ€

* perror functionæ‰“å°å¯è¯»çš„ä¿¡æ¯

##### æ–‡ä»¶æè¿°ç¬¦çš„æ“ä½œ

* int read(int fd, void *buf, int nbytes);
  * Returns number of bytes read
  * Returns 0 bytes at end of file, or -1 on error
* int write (int fd, const void *buf, int nbytes);
  * int write (int fd, const void *buf, int nbytes);
* int write (int fd, const void *buf, int nbytes);
  * whence: 0 â€“ start, 1 â€“ current, 2 â€“ end
    * Returns previous file oset, or -1 on error
* int close (int fd);

##### æ–‡ä»¶æè¿°ç¬¦numbers

* æ–‡ä»¶æè¿°ç¬¦ç”±è¿›ç¨‹ç»§æ‰¿
  * å½“ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºå¦ä¸€ä¸ªè¿›ç¨‹ï¼Œ é»˜è®¤ä¼šæ˜¯åŒä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦
* Descriptors 0, 1, and 2 have special meaning
  * Descriptors 0, 1, and 2 have special meaning
  * 1 â€“ â€œstandard outputâ€ (stdout, printf in ANSI C)
  * 2 â€“ â€œstandard errorâ€ (stderr, perror in ANSI C)
  * Normally all three attached to terminal
* ä¾‹å­ï¼štype.c
  * ä½¿ç”¨stdoutæ‰“å°æ–‡ä»¶çš„æ‰€æœ‰å†…å®¹

```c
void typefile(char* filename)
{
    int fd, nread;
    char buf[1024];
    
    fd = open(filename, O_RDONLY);
    if (fd == -1)
    {
        perror(filename);
        return;
    }
    
    while((nread = read(fd, buf, sizeof(buf))) > 0))
    {
        write(1, buf, nread);
    }
    
    close(fd);
}
```

##### ä¿æŠ¤ä¾‹å­ï¼šCPUæŠ¢å 

* ä¿æŠ¤æœºåˆ¶é˜²æ­¢ç‹¬å CPU
* kernel programs timer to interrupt every 10 ms
  * Must be in supervisor mode to write appropriate I/O registers
  * Must be in supervisor mode to write appropriate I/O registers
* Kernel sets interrupt to vector back to kernel
  * \- Regains control whenever interval timer fires
  * Gives CPU to another process if someone else needs it
  * Gives CPU to another process if someone else needs it
  * No way for user code to hijack interrupt handler
* ä¸èƒ½é€šè¿‡æ— é™å¾ªç¯ç‹¬å CPU
  * At worst get 1/N of CPU with N CPU-hungry processes

##### ä¿æŠ¤ä¸æ˜¯å®‰å…¨çš„

* å¦‚ä½•ç‹¬å CPU
* ä½¿ç”¨å¤šè¿›ç¨‹
* For many years, could wedge most OSes with
  * int main() { while(1) fork(); }
  * Keeps creating more processes until system out of proc. slots
* å…¶ä»–æŠ€æœ¯ï¼šuse all memory (chill program)
* Typically solved with technical/social combination
  * Typically solved with technical/social combination
  * Social: Reboot and yell at annoying users
  * Social: Ban harmful apps from play store

##### åœ°å€è½¬æ¢

* Protect memory of one program from actions of another
* Definitions
  * Address spaceï¼ˆåœ°å€ç©ºé—´ï¼‰ï¼šall memory locations a program can name
  * Virtual addressï¼ˆè™šæ‹Ÿåœ°å€ï¼‰ï¼šaddresses in processâ€™ address space
  * Physical addressï¼ˆç‰©ç†åœ°å€ï¼‰ï¼šaddress of real memory
  * Translationï¼ˆè½¬æ¢ï¼‰ï¼šmap virtual to physical addresses
* Translation done on every load and store
  * Modern CPUs do this in hardware for speed
* Idea: If you canâ€™t name it, you canâ€™t touch it
  * Ensure one processâ€™s translations donâ€™t include any other processâ€™s memory

##### æ›´å¤šçš„å†…å­˜ä¿æŠ¤

* CPU allows kernel-only virtual addresses
  * Kernel typically part of all address spaces,
  * But must ensure apps canâ€™t touch kernel memory
* CPU lets OS disable (invalidate) particular virtual addresses
  * Catch and halt buggy program that makes wild accesses
  * Catch and halt buggy program that makes wild accesses
* CPU enforced read-only virtual addresses useful
  * allows sharing of code pages between processes
  * allows sharing of code pages between processes
* CPU enforced execute disable of VAs
  * Makes certain code injection attacks harder

##### ä¸åŒç³»ç»Ÿçš„ä¸Šä¸‹é—®

* A CPU (core) is at any point in one of several contexts
* User-level â€“ CPU in user mode running application
* Kernel process context
  * Running kernel code on behalf of a particular process
  * performing system call
  * Also exception (memory fault, numeric exception, etc.)
  * Or executing a kernel-only process (e.g., network file server)
* Kernel code not associated with a process
  * Timer interrupt (hardclock)
  * Device interrupt
  * Device interrupt
*  Context switch code â€“ change which process is running
  *  Context switch code â€“ change which process is running
* Idle â€“ nothing to do (might powerdown CPU)

##### ä¸Šä¸‹æ–‡çš„åˆ‡æ¢

* User â†’ kernel process context: syscall, page fault
* User/process context â†’ interrupt handler: hardware
* Process context â†’ user/context switch: return
* Process context â†’ context switch: sleep
* Context switch â†’ user/process context

##### èµ„æºåˆ†é…å’Œæ€§èƒ½

* Multitasking permits higher resource utilization
* Simple example
  * Process downloading large file mostly waits for network
  * You play a game while downloading the file
  * Higher CPU utilization than if just downloading
* Higher CPU utilization than if just downloading
* Example: Say disk 1,000 times slower than memory
  * 1 GB memory in machine
  * 2 Processes want to run, each use 1 GB
  * Can switch processes by swapping them out to disk
  * Faster to run one at a time than keep context switching

##### Useful properties to exploit

* skew
  * 80% of time taken by 20% of code
  * 10% of memory absorbs 90% of references
  * Basis behind cache: place 10% in fast memory, 90% in slow, usually looks like one big fast memory
* Past predicts future(a.k.a. temporal locality)
  * Whatâ€™s the best cache entry to replace?
  * If past â‰ˆ future, then least-recently-used entry
* Note conflict between fairness & throughput
  * Higher throughput (fewer cache misses, etc.) to keep running same process
  * But fairness says should periodically preempt CPU and give it to next process

## CMU 15-410

[15-410å®˜ç½‘](https://www.cs.cmu.edu/~410/lecture.html)

## Mit6.828

[6.828](https://pdos.csail.mit.edu/6.828/2018/index.html)