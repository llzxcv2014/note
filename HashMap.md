# HashMap

## 1.8改进总结

1. 插入方式  Java7使用的是头插法，Java8开始使用尾插法。

分析：Java7使用的是链表，使用头插法容易出现逆序和环形链表死循环问题。Java8则会在链表长度超过8时会转变为红黑树，并且使用尾插法。避免之前提到的问题

2. 扩容后数据存储位置的计算方式不一样。

分析：Java7是使用hash值和需要扩容的二进制数做与操作(&)
> hashcode() ->> 扰动处理->> (h & length - 1)

Java8则修改了按照扩容后的规律计算
> 扩容后的位置=原位置 or 原位置 + 旧容量

### HashMap的扩容

HashMap扩容，扩容后容量是原来的两倍。扩容后的新位置有两种情况

1. 扩容后，若hash值的新增参与运算的位为0，扩容后的位置为原位置
2. 扩容后，若hash值的新增参与运算的位为1，扩容后的位置为原始位置+扩容前的旧容量

### HashMap的死循环

hashmap死循环出现的场景是两个线程同时对同一个hashmap进行了rehash操作导致。

状态1：

线程1刚好完成扩容，准备进行rehash，线程2执行插入操作

![在这里插入图片描述](HashMap.assets/20190125231950932-1585449546370.png)

状态2：

线程1此时被唤醒执行rehash操作，把key为5的节点挂在数组下标为1的位置上

![在这里插入图片描述](HashMap.assets/20190125232018560.png)

状态3：

从第一个状态开始继续接着处理key为9的节点，所以应该是都挂在桶数组下标为1的链表上顺序为9---->5---->NULL

![在这里插入图片描述](HashMap.assets/20190125232045459.png)

状态4：

此时在第三步时候处理9完毕之后，他发现节点9后面还有一个节点5（这个节点5是因为线程二中已经rehash完毕之后留下的），此时他又会把节点5放在线程一中的首部此时也就是5---->9----5(后面这部分的9–>5是保留的第三个状态留下的)，到这里就形成了死循环。

![在这里插入图片描述](HashMap.assets/2019012523211371.png)

HashMap的rehash过程：

会先遍历hashmap数组元素中的某一条链，然后按照从尾到头的方式将链条中的值重新进行hash然后存储到新的hashmap中去。

 所以上图中原先的hashmap中，本来是5-》9，重新hash后就变成9-》5了。就是rehash时遍历顺序导致的。

导致死循环的原因：

线程2 rehash后 链条变成了9-》5，这时线程一苏醒，它也开始进行rehash，然后遍历链条，这时就出现死循环了，因为9后面已经有5了（这个5是线程2加的），所以线程rehash时就会一直找不到链条的尾部，导致死循环了。

[美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析](https://blog.csdn.net/qq_36520235/article/details/82417949)

[Java源码分析：HashMap 1.8 相对于1.7 到底更新了什么？](https://www.jianshu.com/p/8324a34577a0)

[美团面试题：HashMap是如何形成死循环的？](https://blog.csdn.net/qq_36520235/article/details/86653136)

[HashMap是如何形成死循环的？（读后感）](https://juejin.im/post/5e7635595188252c077a33e4)